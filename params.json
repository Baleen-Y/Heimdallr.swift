{"name":"Heimdall.swift","tagline":"Easy to use OAuth 2 library for iOS, written in Swift.","body":"# <img src=\"https://cloud.githubusercontent.com/assets/460060/8159821/b8bfeb32-136a-11e5-83ed-83b7fe01df3a.jpg\" width=\"30\" height=\"30\"> Heimdall\r\n\r\nHeimdall is an [OAuth 2.0](https://tools.ietf.org/html/rfc6749) client specifically designed for easy usage. It currently supports the [resource owner password credentials grant](https://tools.ietf.org/html/rfc6749#section-4.3) flow, [refreshing an access token](https://tools.ietf.org/html/rfc6749#section-6) as well as [extension grants](https://tools.ietf.org/html/rfc6749#section-4.5).\r\n\r\nIf you are familiar with [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa), also check out [ReactiveHeimdall](https://github.com/rheinfabrik/ReactiveHeimdall)!\r\n\r\nIf you are an Android Developer then please take a look at the [Android version of Heimdall](https://github.com/rheinfabrik/Heimdall.droid).\r\n\r\n[![Build Status](https://circleci.com/gh/rheinfabrik/Heimdall.swift.svg?style=shield&circle-token=06d0c39133fae3dd9b649c116776c7f882885f1f)](https://circleci.com/gh/rheinfabrik/Heimdall.swift)\r\n\r\n## Example\r\n\r\nBefore requesting an access token, the client must be configured appropriately:\r\n\r\n```swift\r\nlet tokenURL = NSURL(string: \"http://example.com/oauth/v2/token\")!\r\nlet heimdall = Heimdall(tokenURL: tokenURL)\r\n```\r\n\r\nOn login, the resource owner's password credentials are used to request an access token:\r\n\r\n```swift\r\nheimdall.requestAccessToken(username: \"johndoe\", password: \"A3ddj3w\") { result in\r\n    switch result {\r\n    case .Success:\r\n        println(\"success\")\r\n    case .Failure(let error):\r\n        println(\"failure: \\(error.unbox.localizedDescription)\")\r\n    }\r\n}\r\n```\r\n\r\nHeimdall automatically persists the access token. Afterwards, any `NSURLRequest` can be easily authenticated using the received access token:\r\n\r\n```swift\r\nvar session: NSURLSession!\r\nvar request: NSURLRequest!\r\n\r\nheimdall.authenticateRequest(request) { result\r\n    switch result {\r\n    case .Success(let request):\r\n        let task = session.dataTaskWithRequest(request.unbox) { data, response, error in\r\n            // ...\r\n        }\r\n\r\n        task.resume()\r\n    case .Failure(let error):\r\n        println(\"failure: \\(error.unbox.localizedDescription)\")\r\n    }\r\n}\r\n```\r\n\r\n## Installation\r\n\r\n### Carthage\r\n\r\n[Carthage](https://github.com/Carthage/Carthage) is a simple, decentralized dependency manager for Cocoa.\r\n\r\n1. Add Heimdall to your [Cartfile](https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md#cartfile):\r\n\r\n  ```\r\n  github \"rheinfabrik/Heimdall.swift\" ~> 1.1\r\n  ```\r\n\r\n2. Run `carthage update` to fetch and build Heimdall and its dependencies.\r\n\r\n3. [Make sure your application's target links against `Heimdall.framework` and copies all relevant frameworks into its application bundle (iOS); or embeds the binaries of all relevant frameworks (Mac).](https://github.com/carthage/carthage#getting-started)\r\n\r\n## Usage\r\n\r\n### OAuthClientCredentials\r\n\r\nThe client credentials, consisting of the client's identifier and optionally its secret, are used for authenticating with the token endpoint:\r\n\r\n```swift\r\nvar identifier: String!\r\nvar secret: String!\r\n\r\nlet credentials = OAuthClientCredentials(id: identifier)\r\n               // OAuthClientCredentials(id: identifier, secret: secret)\r\n```\r\n\r\n*Please note that native applications are considered to be [public clients](https://tools.ietf.org/html/rfc6749#section-2.1).*\r\n\r\n### OAuthAccessTokenStore\r\n\r\nAn access token store is used to (persistently) store an access token received from the token endpoint. It must implement the following storage and retrieval methods:\r\n\r\n```swift\r\nprotocol OAuthAccessTokenStore {\r\n    func storeAccessToken(accessToken: OAuthAccessToken?)\r\n    func retrieveAccessToken() -> OAuthAccessToken?\r\n}\r\n```\r\n\r\nHeimdall ships with an already built-in persistent Keychain-based access token store, using [KeychainAccess](https://github.com/kishikawakatsumi/KeychainAccess). The service is configurable:\r\n\r\n```swift\r\nvar service: String!\r\n\r\nlet accessTokenStore = OAuthAccessTokenKeychainStore(service: service)\r\n```\r\n\r\n### HeimdallHTTPClient\r\n\r\nAn HTTP client that can be used by Heimdall for requesting access tokens. It must implement the following `sendRequest` method:\r\n\r\n```swift\r\nprotocol HeimdallHTTPClient {\r\n    func sendRequest(request: NSURLRequest, completion: (data: NSData!, response: NSURLResponse!, error: NSError?) -> ())\r\n}\r\n```\r\n\r\nFor convenience, a default HTTP client named `HeimdallHTTPClientNSURLSession` and based on `NSURLSession` is provided. It may be configured with an `NSURLSession`:\r\n\r\n```swift\r\nvar urlSession: NSURLSession!\r\n\r\nlet httpClient = HeimdallHTTPClientNSURLSession(urlSession: session)\r\n```\r\n\r\n### Heimdall\r\n\r\nHeimdall must be initialized with the token endpoint URL and can optionally be configured with client credentials, an access token store and an HTTP client:\r\n\r\n```swift\r\nvar tokenURL: NSURL!\r\n\r\nlet heimdall = Heimdall(tokenURL: tokenURL)\r\n            // Heimdall(tokenURL: tokenURL, credentials: credentials)\r\n            // Heimdall(tokenURL: tokenURL, credentials: credentials, accessTokenStore: accessTokenStore)\r\n            // Heimdall(tokenURL: tokenURL, credentials: credentials, accessTokenStore: accessTokenStore, httpClient: httpClient)\r\n            // Heimdall(tokenURL: tokenURL, credentials: credentials, accessTokenStore: accessTokenStore, httpClient: httpClient, resourceRequestAuthenticator: resourceRequestAuthenticator)\r\n```\r\n\r\nWhether the client's access token store currently holds an access token can be checked using the `hasAccessToken` property. *It's not checked whether the stored access token, if any, has already expired.*\r\n\r\nThe `authorize` method takes the resource owner's password credentials as parameters and uses them to request an access token from the token endpoint:\r\n\r\n```swift\r\nvar username: String!\r\nvar password: String!\r\n\r\nheimdall.requestAccessToken(username: username, password: password) { result in\r\n    // ...\r\n}\r\n```\r\n\r\n*The `completion` closure may be invoked on any thread.*\r\n\r\nOnce successfully authorized, any `NSURLRequest` can be easily altered to include authentication via the received access token:\r\n\r\n```swift\r\nvar request: NSURLRequest!\r\n\r\nheimdall.authenticateRequest(request) { result\r\n    // ...\r\n}\r\n```\r\n\r\nIf the access token has already expired and a refresh token is available, Heimdall will automatically refresh the access token. *Refreshing requires network I/O.* *The `completion` closure may be invoked on any thread.*\r\n\r\n### HeimdallResourceRequestAuthenticator\r\n\r\nBy default, Heimdall authenticates a request by setting the HTTP header field `Authorization`. This behavior can be changed by passing another resource request authenticator implementing `HeimdallResourceRequestAuthenticator` to the initializer.\r\n\r\n## About\r\n\r\nHeimdall was built by [Rheinfabrik](http://www.rheinfabrik.de) üè≠\r\n\r\n## Credits\r\n\r\nContains code for query string escaping taken from [Alamofire](https://github.com/Alamofire/Alamofire/) (MIT License)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}